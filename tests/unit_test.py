import sys
import os
from time import sleep
from pathlib import Path

import pytest
import subprocess
from core import analyser
from core.utils.sonarqube_utils import get_duplication_map
from utils.general_utils import check_and_validate_file_path
sys.path.insert(0, os.path.abspath(
    os.path.join(os.path.dirname(__file__), '..')))


@pytest.fixture(scope="session", autouse=True)
def spawn_up_wiremock_server():
    print("Trigger Shell Command to bring up WireMock Container")
    subprocess.call(['sh', './wiremock_using_docker.sh'])
    sleep(10)
    # Example: Start WireMock, setup database connection


""""
def test_get_issues_by_type():
    mock_response=Mock()
    file=open("tests/sample_response.json")
    data=json.load(file)
    mock_response.json.return_value = data
    component_list, fix_list, line_number, impact, issue_type_list = get_issues_by_type(mock_response, "CODE_SMELL")
    expected_component_list=["app.py","app.py"]
    expected_line_list=[27,27]
    expected_impact_list=["LOW","MEDIUM"]
    ##assert component_list == expected_component_list
    assert line_number==expected_line_list
    assert impact==expected_impact_list

"""


def test_duplicate_line_density():
    duplicate_line_density_actual = analyser.get_duplication_density(
        "localhost:8000", "car-loan-portal", "squ_aa9488007125b09c46e8e2a16a5bccd822738bc2", "http")
    duplicate_line_density_expected = "15.0"
    assert duplicate_line_density_actual == duplicate_line_density_expected, "Actual Duplicate Line Density and Expected Duplicate Line Density does not match"


def test_duplicate_lines():
    actual_duplicate_lines_map = get_duplication_map(
        "localhost:8000", "car-loan-portal", "squ_aa9488007125b09c46e8e2a16a5bccd822738bc2", "http")
    expected_duplicate_lines_map = {"app.py": "60"}
    assert actual_duplicate_lines_map == expected_duplicate_lines_map, "Difference in Hash Map found for Actual Duplicated Line Map and Expected Duplicated Line Map"


@pytest.mark.parametrize("path_name,case", [
    ("car-loan-report.pdf", "file_name_with_pdf"),
    ("car-loan-report", "file_name_without_pdf_extenstion"),
    ("/Uxser", "invalid_directory_name"),
    ("/Uxser/car-loan-report.pdf", "invalid_directory_name_ending_with_pdf"),
    (Path.home() / "Desktop", "random")
])
def test_path_validation(path_name, case):
    returned_result = check_and_validate_file_path(path_name)
    if case == "file_name_wit_pdf":
        assert returned_result == "car-loan-report.pdf", "Mismatch in Path found"
    elif case == "invalid_directory_name" or case == "invalid_directory_name_ending_with_pdf":
        resolved_path = Path.home() / "Downloads" / "generated-sonarqube-report.pdf"
        assert returned_result == resolved_path, "Mismatch in Path found"
    elif case == "random":
        print("Hello from Alaska"+ str(Path.home()))
        resolved_path = Path.home() / "Desktop" / "generated-sonarqube-report.pdf"
        assert returned_result == resolved_path, "Mismatch in Path found"

## ------Generated by Keploy----------
def test_get_issues_by_type_filter_correctly():
    mock_response = Mock()
    mock_response.json.return_value = {
        "issues": [
            {"type": "CODE_SMELL", "component": "app.py", "message": "Refactor this code", "line": 27, "severity": "MEDIUM"},
            {"type": "BUG", "component": "main.py", "message": "Fix this bug", "line": 45, "severity": "HIGH"}
        ]
    }
    component_list, fix_list, line_number, impact, issue_type_list = analyser.get_issues_by_type(mock_response, "CODE_SMELL")
    assert component_list == ["app.py"]
    assert fix_list == ["Refactor this code"]
    assert line_number == [27]
    assert impact == ["MEDIUM"]
    assert issue_type_list == ["CODE_SMELL"]

def test_generate_final_report_and_transmit_to_sentry_templating_failure(monkeypatch):
    def mock_create_issues_report(*args, **kwargs):
        return 0  # Simulate templating error
    
    monkeypatch.setattr(templating, "create_issues_report", mock_create_issues_report)
    
    result = analyser.generate_final_report_and_transmit_to_sentry("mock_path", "localhost", "test_project", "fake_token", "http")
    
    assert result == "", "Expected empty string due to templating failure"

def test_get_info_for_sentry_analysis_failed_version_request(monkeypatch):
    def mock_get(*args, **kwargs):
        response_mock = MagicMock()
        response_mock.status_code = 500
        return response_mock
    
    monkeypatch.setattr(requests, "get", mock_get)
    
    version, language = analyser.get_info_for_sentry_analysis("localhost", "mock_project", "mock_token", "http")
    
    assert version == "NOT SET", "Expected 'NOT SET' version on request failure"


def test_get_issues_by_type_no_issues():
    mock_response = MagicMock()
    mock_response.json.return_value = {"issues": []}
    
    component_list, fix_list, line_number, impact, issue_type_list = analyser.get_issues_by_type(mock_response, "BUG")
    
    assert component_list == [], "Expected empty component list"
    assert fix_list == [], "Expected empty fix list"
    assert line_number == [], "Expected empty line number list"
    assert impact == [], "Expected empty impact list"
    assert issue_type_list == [], "Expected empty issue type list"
